-- Cr√©er le ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
screenGui.ResetOnSpawn = false

-- Cr√©er un Frame pour contenir les boutons
local frame = Instance.new("Frame")
frame.Parent = screenGui
frame.Size = UDim2.new(0, 350, 0, 400)
frame.Position = UDim2.new(0.5, -175, 0.5, -200)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
frame.BorderSizePixel = 0
frame.Visible = true

-- Fonction pour styliser les boutons
local function createButton(text, position, parent)
    local button = Instance.new("TextButton")
    button.Parent = parent
    button.Size = UDim2.new(0, 300, 0, 50)
    button.Position = position
    button.Text = text
    button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.Font = Enum.Font.GothamBold
    button.TextSize = 18
    button.BorderSizePixel = 0
    return button
end

-- Cr√©ation des boutons
local autoCoinButton = createButton("Activate Auto Coin", UDim2.new(0, 25, 0, 20), frame)
local autoDummyButton = createButton("Activate Auto Dummy 5k", UDim2.new(0, 25, 0, 80), frame)
local hitboxButton = createButton("Show/Hide Hitboxes", UDim2.new(0, 25, 0, 140), frame)
local spamWeaponButton = createButton("Activate Spam Weapon", UDim2.new(0, 25, 0, 200), frame)
local farmKillButton = createButton("Activate Farm Kill", UDim2.new(0, 25, 0, 260), frame)

-- Fonction pour activer/d√©sactiver un bouton
local function toggleButton(button, state, scriptName)
    if state then
        button.Text = "Deactivate " .. scriptName
    else
        button.Text = "Activate " .. scriptName
    end
end

-- **Auto Coin Script**
-- Activer l'auto-collecte imm√©diatement apr√®s l'ex√©cution du script
local autoCollect = true 

-- Fonction pour collecter les coins en boucle
local function collectCoins()
    while autoCollect do
        game:GetService("ReplicatedStorage").Events.CoinEvent:FireServer()
        task.wait(0.1) -- Temps ajustable pour √©viter le spam
    end
end

-- Lancer la collecte dans un thread s√©par√©
spawn(collectCoins)

-- Notification pour indiquer que l'auto-collecte est activ√©e
Rayfield:Notify({
    Title = "Auto Coin Activ√©",
    Content = "La collecte automatique des pi√®ces a commenc√©.",
    Duration = 6.5,
    Image = 4483362458, -- Remplace par l'ID de ton ic√¥ne
})

-- **Auto Dummy 5k Level Script**
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- RemoteEvent pour tirer la fireball
local FireballEvent = ReplicatedStorage:WaitForChild("SkillsInRS"):WaitForChild("RemoteEvent")

-- RemoteEvent pour hit le dummy
local HitEvent = ReplicatedStorage:WaitForChild("jdskhfsIIIllliiIIIdchgdIiIIIlIlIli")

-- Coordonn√©es du tir (modifiable pour suivre un ennemi)
local fireballPosition = Vector3.new(-83.33870697021484, 595.9384765625, 812.44775390625)
local projectileType = "NewFireball"

-- Cible du hit (assure-toi que ce chemin est valide)
local dummyHumanoid = workspace:FindFirstChild("MAP"):FindFirstChild("5k_dummies").Dummy2:FindFirstChild("Humanoid")

-- D√©lais
local fireballCooldown = 2 -- Temps entre chaque tir
local hitCooldown = 0.1 -- Temps entre chaque hit

-- Fonction pour tirer les fireballs en boucle
task.spawn(function()
    while true do
        local fireballArgs = {
            [1] = fireballPosition,
            [2] = projectileType
        }
        FireballEvent:FireServer(unpack(fireballArgs))
        task.wait(fireballCooldown)
    end
end)

-- Fonction pour spammer les hits sur le dummy
task.spawn(function()
    while true do
        local hitArgs = {
            [1] = dummyHumanoid,
            [2] = 1 -- D√©g√¢ts ou autre param√®tre
        }
        HitEvent:FireServer(unpack(hitArgs))
        task.wait(hitCooldown)
    end
end)

-- **Hitbox Script**
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local localPlayer = Players.LocalPlayer
local DamageEvent = ReplicatedStorage:WaitForChild("SkillsInRS"):WaitForChild("DamageIndicatorEvent")

local hitboxes = {}  -- Stocke les hitbox des autres joueurs
local hitboxSize = Vector3.new(5, 5, 5)  -- Taille initiale des hitbox
local debounce = false  -- √âvite le spam d‚Äôattaques
local guiEnabled = true -- Afficher/Cacher le GUI

-- üìú Cr√©ation de la GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = localPlayer:WaitForChild("PlayerGui")
screenGui.ResetOnSpawn = false

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 250, 0, 150)
frame.Position = UDim2.new(0.05, 0, 0.2, 0)
frame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
frame.BorderSizePixel = 0
frame.Visible = guiEnabled
frame.Parent = screenGui

local titleLabel = Instance.new("TextLabel")
titleLabel.Text = "Hitbox Manager"
titleLabel.Size = UDim2.new(1, 0, 0, 30)
titleLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.Parent = frame

local slider = Instance.new("Frame")
slider.Size = UDim2.new(1, -20, 0, 10)
slider.Position = UDim2.new(0, 10, 0, 50)
slider.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
slider.BorderSizePixel = 0
slider.Parent = frame

local knob = Instance.new("Frame")
knob.Size = UDim2.new(0, 20, 0, 20)
knob.Position = UDim2.new(0.5, -10, 0, -5)
knob.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
knob.BorderSizePixel = 0
knob.Parent = slider

local toggleGuiButton = Instance.new("TextButton")
toggleGuiButton.Size = UDim2.new(1, -20, 0, 30)
toggleGuiButton.Position = UDim2.new(0, 10, 0, 90)
toggleGuiButton.Text = "Close GUI"
toggleGuiButton.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
toggleGuiButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleGuiButton.Parent = frame

-- üî≤ Cr√©ation des hitboxs (uniquement pour les autres joueurs)
local function createHitbox(player)
    if not player or not player.Character then return end
    if player == localPlayer then return end  -- Ignore ta propre hitbox

    local character = player.Character
    local rootPart = character:FindFirstChild("HumanoidRootPart")

    if not rootPart then return end

    -- Supprime l'ancienne hitbox si elle existe d√©j√†
    if hitboxes[player] then
        hitboxes[player]:Destroy()
    end

    -- Cr√©ation de la hitbox
    local hitbox = Instance.new("Part")
    hitbox.Size = hitboxSize
    hitbox.Transparency = 0.5
    hitbox.Color = Color3.fromRGB(255, 0, 0)
    hitbox.Material = Enum.Material.ForceField
    hitbox.Anchored = true  -- Important : pour que la position soit mise √† jour via Heartbeat
    hitbox.CanCollide = false
    hitbox.Parent = game.Workspace
    hitbox.Name = "Hitbox"

    hitboxes[player] = hitbox
end

-- üé≠ Mise √† jour en temps r√©el de la hitbox pour suivre parfaitement le joueur
RunService.Heartbeat:Connect(function()
    for player, hitbox in pairs(hitboxes) do
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character.HumanoidRootPart
            hitbox.Position = rootPart.Position  -- Suivi pr√©cis m√™me si le joueur court
        end
    end
end)

-- üéõÔ∏è Changer la taille des hitbox avec le slider
local dragging = false

knob.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local relativeX = math.clamp(input.Position.X - slider.AbsolutePosition.X, 0, slider.AbsoluteSize.X)
        knob.Position = UDim2.new(0, relativeX - knob.Size.X.Offset / 2, 0, -5)

        local newScale = 2 + (relativeX / slider.AbsoluteSize.X) * 10 -- Taille entre 2 et 12
        hitboxSize = Vector3.new(newScale, newScale + 2, newScale)

        for _, hitbox in pairs(hitboxes) do
            hitbox.Size = hitboxSize
        end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = false
    end
end)

-- üéõÔ∏è Toggle GUI
toggleGuiButton.MouseButton1Click:Connect(function()
    guiEnabled = not guiEnabled
    frame.Visible = guiEnabled
    toggleGuiButton.Text = guiEnabled and "Close GUI" or "Open GUI"
end)

-- üéÆ G√©rer les joueurs d√©j√† pr√©sents et les nouveaux arrivants
for _, player in pairs(Players:GetPlayers()) do
    if player ~= localPlayer and player.Character then
        createHitbox(player)
    end
    player.CharacterAdded:Connect(function()
        createHitbox(player)
    end)
end

Players.PlayerAdded:Connect(function(player)
    if player ~= localPlayer then
        player.CharacterAdded:Connect(function()
            createHitbox(player)
        end)
    end
end)

-- **Spam Weapon Script**
local event = game:GetService("ReplicatedStorage").Events.WeaponEvent
local unequipArgs1 = { [1] = "None" }
local unequipArgs2 = { [1] = "S0" }

-- Fonction pour cacher le menu des armes
local function hideWeaponMenu()
    local player = game:GetService("Players").LocalPlayer
    if player and player:FindFirstChild("PlayerGui") then
        for _, gui in pairs(player.PlayerGui:GetChildren()) do
            if gui:IsA("ScreenGui") and gui.Name:lower():find("weapon") then
                gui.Enabled = false
            end
        end
    end
end

while true do
    for i = 1, 9 do -- Seulement de S1 √† S9
        local args = { [1] = "S" .. i }

        -- Cache le menu avant chaque action
        hideWeaponMenu()

        -- √âquipe l'arme
        event:FireServer(unpack(args))
        task.wait(0.15) -- D√©lai rapide

        -- D√©s√©quipe l'arme avec les deux m√©thodes
        event:FireServer(unpack(unequipArgs1))
        task.wait(0.1) -- Encore plus rapide
        event:FireServer(unpack(unequipArgs2))
        task.wait(0.1)

        -- Cache √† nouveau le menu pour √©viter qu'il r√©apparaisse
        hideWeaponMenu()
    end
end
-- **Farm Kill Script**
local player = game:GetService("Players").LocalPlayer
local replicatedStorage = game:GetService("ReplicatedStorage")
local character, humanoid

-- Fonction pour t√©l√©porter le joueur aux 5k_dummies
local function teleportToDummies()
    character = player.Character or player.CharacterAdded:Wait()

    if character then
        local dummiesFolder = workspace:FindFirstChild("MAP") and workspace.MAP:FindFirstChild("5k_dummies")
        if dummiesFolder then
            local targetDummy = dummiesFolder:FindFirstChild("Dummy2") -- Modifier si besoin

            if targetDummy and targetDummy:FindFirstChild("HumanoidRootPart") then
                -- T√©l√©portation au dummy
                character:MoveTo(targetDummy.HumanoidRootPart.Position + Vector3.new(0, 3, 0)) -- +3 pour √©viter les collisions
                return true -- Retourne vrai si la t√©l√©portation a r√©ussi
            end
        end
    end
    return false -- Retourne faux si la t√©l√©portation a √©chou√©
end

-- Fonction pour appliquer le hit et tuer instantan√©ment le joueur
local function autoKill()
    character = player.Character
    humanoid = character and character:FindFirstChild("Humanoid")

    if humanoid then
        -- T√©l√©porter et s'assurer que la t√©l√©portation est bien faite
        local success = teleportToDummies()

        if success then
            -- Attendre un court instant pour √™tre s√ªr que le joueur est bien sur la position
            task.wait(1) 

            -- Ajouter 1 hit sur soi-m√™me
            local hitArgs = {
                [1] = humanoid,
                [2] = 1
            }
            replicatedStorage.jdskhfsIIIllliiIIIdchgdIiIIIlIlIli:FireServer(unpack(hitArgs))

            -- Attendre un petit instant pour que le hit soit bien enregistr√©
            task.wait(0.3)

            -- Tue instantan√©ment le joueur
            humanoid.Health = 0

            -- Envoyer le Remote Event pour comptabiliser le kill
            local killArgs = {
                [1] = humanoid,
                [2] = 40206 -- Score du kill
            }
            replicatedStorage.SkillsInRS.DamageIndicatorEvent:FireServer(unpack(killArgs))
        end
    end
end

-- For√ßage du respawn imm√©diat
local function forceRespawn()
    if player then
        task.wait(0.1) -- Court d√©lai pour √©viter des erreurs de chargement
        player:LoadCharacter() -- Respawn instantan√©ment
    end
end

-- Ex√©cuter l'auto-kill apr√®s la t√©l√©portation compl√®te
player.CharacterAdded:Connect(function()
    task.wait(0.5) -- Laisser le temps au personnage de charger
    autoKill() -- Ex√©cuter imm√©diatement l'auto-kill apr√®s le spawn
end)

-- D√©tecter la mort et forcer le respawn imm√©diat
player.CharacterRemoving:Connect(function()
    task.wait(0.1) -- Petit d√©lai pour √©viter les erreurs
    forceRespawn() -- Forcer le respawn
end)

-- Lancer imm√©diatement au d√©but
autoKill()


-- Fonction pour fermer/ouvrir le GUI
local toggleGUIButton = createButton("Close GUI", UDim2.new(0, 25, 0, 320), frame)
toggleGUIButton.MouseButton1Click:Connect(function()
    frame.Visible = not frame.Visible
    toggleGUIButton.Text = frame.Visible and "Close GUI" or "Open GUI"
end)
